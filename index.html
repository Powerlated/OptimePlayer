<html>

<head>
    <title>Optime Player</title>

    <style>
        @font-face {
            font-family: HindSiliguri;
            src: url('fonts/HindSiliguri-Regular.ttf');
        }

        body {
            font-family: HindSiliguri;

            text-align: center;
        }

        #drop-zone {
            display: flex;
            align-items: center;
            justify-content: center;

            /* display: none; */

            background: gray;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            opacity: .8;

            font-size: 32px;

            visibility: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 0.7fr 1.5fr 0.8fr;
            grid-template-rows: 0.7fr 1.3fr 1fr;
            gap: 0px 0px;
            grid-template-areas:
                "song-picker channels ."
                "song-picker . ."
                "song-picker . .";
        }

        .song-picker {
            grid-area: song-picker;

            display: flex;
            flex-direction: column;
        }

        .channels {
            grid-area: channels;
        }
    </style>

    <script>
        //@ts-check
        class AudioPlayer {
            bufferLength;
            sampleRate;
            needMoreSamples;

            bufferPool;
            bufferPoolAt = 0;

            safariHax = false;

            constructor(bufferLength, sampleRate, needMoreSamples) {
                if (!AudioBuffer.prototype.copyToChannel) this.safariHax = true;

                this.bufferLength = bufferLength;
                this.sampleRate = sampleRate;
                this.needMoreSamples = needMoreSamples;

                const AudioContext = window.AudioContext   // Normal browsers
                    //@ts-ignore
                    || window.webkitAudioContext; // Sigh... Safari

                this.ctx = new AudioContext({ sampleRate: sampleRate });

                this.bufferPool = this.genBufferPool(256, this.bufferLength);

                const fixAudioContext = () => {
                    // Create empty buffer
                    let buffer = this.ctx.createBuffer(1, 1, 22050);
                    let source = this.ctx.createBufferSource();
                    source.buffer = buffer;
                    // Connect to output (speakers)
                    source.connect(this.ctx.destination);
                    // Play sound
                    if (source.start) {
                        source.start(0);
                    } else if (source.play) {
                        source.play(0);
                    } else if (source.noteOn) {
                        source.noteOn(0);
                    }
                };
                // iOS 6-8
                document.addEventListener('touchstart', fixAudioContext);
                // iOS 9
                document.addEventListener('touchend', fixAudioContext);

                this.gain = this.ctx.createGain();
                this.gain.gain.value = 0.25;
                this.gain.connect(this.ctx.destination);
            }

            gain;

            /** @type {AudioContext} */
            ctx;
            sourcesPlaying = 0;

            genBufferPool(count, length) {
                let pool = new Array(count);
                for (let i = 0; i < count; i++) {
                    pool[i] = this.ctx.createBuffer(2, length, this.sampleRate);
                }
                return pool;
            }

            queueAudio(bufferLeft, bufferRight) {
                let buffer = this.bufferPool[this.bufferPoolAt];
                this.bufferPoolAt++;
                this.bufferPoolAt &= 255;

                if (!this.safariHax) {
                    buffer.copyToChannel(bufferLeft, 0);
                    buffer.copyToChannel(bufferRight, 1);
                } else {
                    buffer.getChannelData(0).set(bufferLeft);
                    buffer.getChannelData(1).set(bufferRight);
                }

                let bufferSource = this.ctx.createBufferSource();

                bufferSource.onended = () => {
                    this.sourcesPlaying--;
                    if (this.sourcesPlaying < 3) {
                        this.needMoreSamples();
                    }
                    if (this.sourcesPlaying < 2) {
                        this.needMoreSamples();
                    }
                };

                // if (this.audioSec <= this.ctx.currentTime + 0.05) {
                // Reset time if close to buffer underrun
                // this.audioSec = this.ctx.currentTime + 0.06;
                // }
                bufferSource.buffer = buffer;
                bufferSource.connect(this.gain);
                bufferSource.start(this.audioSec);

                this.sampleRate = this.sampleRate;
                this.audioSec += this.bufferLength / this.sampleRate;

                this.sourcesPlaying++;
            }

            audioSec = 0;

            reset() {
                // 50 ms buffer
                this.audioSec = this.ctx.currentTime + 0.06;
                // console.log(`Latency in seconds: ${(LATENCY / this.sampleRate)}`)
            }
        }

        function read16LE(data, addr) {
            return data[addr] | (data[addr + 1] << 8);
        }

        function read32LE(data, addr) {
            return data[addr] | (data[addr + 1] << 8) | (data[addr + 2] << 16) | (data[addr + 3] << 24);
        }

        function pad(n, width, z) {
            z = z || '0';
            n = n + '';
            return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
        }

        function hex(i, digits) {
            return `0x${pad(i.toString(16), digits, '0').toUpperCase()}`;
        }

        function hexN(i, digits) {
            return pad(i.toString(16), digits, '0').toUpperCase();
        }

        class CircularBuffer {
            /** @param {number} size */
            constructor(size) {
                this.size = size;
                this.buffer = new Array(size);

                this.entries = 0;
                this.readPos = 0;
                this.writePos = 0;
            }

            insert(data) {
                if (this.entries < this.size) {
                    this.entries++;
                    this.buffer[this.writePos++] = data;

                    if (this.writePos >= this.size) {
                        this.writePos = 0;
                    }

                    return true;
                }

                alert("CircularBuffer: overflow");

                return false;
            }

            pop() {
                let data;
                if (this.entries > 0) {
                    this.entries--;
                    data = this.buffer[this.readPos++];

                    if (this.readPos >= this.size) {
                        this.readPos = 0;
                    }
                }
                else {
                    alert("CircularBuffer: underflow");
                    data = null;
                }
                return data;
            }

            peek(offset) {
                return this.buffer[(this.readPos + offset) % this.size];
            }

            reset() {
                this.entries = 0;
                this.readPos = 0;
                this.writePos = 0;
            }
        }

        class SseqInfo {
            constructor() {
                this.fileId = null;
                this.bank = null;
                this.volume = null;
                this.cpr = null; // what the hell does this mean?
                this.ppr = null; // what the hell does this mean?
                this.ply = null; // what the hell does this mean?
            }
        }

        class SsarInfo {
            constructor() {
                this.fileId = null;
            }
        }

        class BankInfo {
            constructor() {
                this.fileId = null;
                this.swarId = new Uint8Array(4);
            }
        }

        class SwarInfo {
            constructor() {
                this.fileId = null;
            }
        }

        class Sdat {
            constructor() {
                /** @type {Uint8Array[]} */
                this.fat = [];

                /** @type {SseqInfo[] | null} */
                this.sseqInfos = [];
                this.sseqNameIdDict = [];
                this.sseqIdNameDict = [];

                this.sbnkNameIdDict = [];
                this.sbnkIdNameDict = [];

                /** @type {SsarInfo[] | null} */
                this.ssarInfos = [];

                /** @type {BankInfo[] | null} */
                this.sbnkInfos = [];

                /** @type {SwarInfo[] | null} */
                this.swarInfos = [];

                /** @type {Bank[]} */
                this.banks = new Array(128);

                /** @type {Sample[][]} */
                this.sampleArchives = new Array(256).fill(null).map(() => new Array());
            }
        }

        class Message {
            constructor(channel, type, param0, param1, param2) {
                this.track = channel;
                this.type = type;
                this.param0 = param0;
                this.param1 = param1;
                this.param2 = param2;
            }
        }

        const MessageType = {
            PlayNote: 0, // P0: MIDI Note P1: Velocity
            InstrumentChange: 1, // P0: Bank P1: Program
        }

        class PsgSquareInstrument {
            constructor(sampleRate) {
                this.valL = 0;
                this.valR = 0;
                this.frequency = 440;
                this.sampleRate = sampleRate;
                this.volume = 1;

                this.playing = false;
            }

            sampleAt(sample) {
                let t = sample / this.sampleRate;

                let continuePlaying = true;

                // TODO: a better envelope
                let envVol = 0;
                if (t < 0.4) {
                    envVol = 1 - t / 0.4;
                } else {
                    envVol = 0;
                    continuePlaying = false;
                }

                let periodTime = 1 / this.frequency;

                if ((t % periodTime) >= periodTime / 2) {
                    this.valL = this.volume * envVol;
                    this.valR = this.volume * envVol;
                } else {
                    this.valL = -this.volume * envVol;
                    this.valR = -this.volume * envVol;
                }

                return continuePlaying;
            }
        }

        class Sample {
            /**
            * @param {Float64Array} data 
            * @param {number} frequency
            * @param {number} sampleRate
            */
            constructor(data, frequency, sampleRate, looping, loopPoint) {
                this.data = data;
                this.frequency = frequency;
                this.sampleRate = sampleRate;
                this.looping = looping;
                this.loopPoint = loopPoint;

                this.sampleLength = 0;
            }
        }

        const InstrumentType = {
            SingleSample: 0x1,
            PsgPulse: 0x2,
            PsgNoise: 0x3,

            Drumset: 0x10,
            MultiSample: 0x11
        }

        class InstrumentRecord {
            // fRecord = 0x1 - Single-Region Instrument
            // fRecord = 0x2 - PSG Pulse
            // fRecord = 0x3 - PSG Noise

            // fRecord = 0x10 - Drumset
            // fRecord = 0x11 - Multi-Region Instrument

            constructor() {
                this.fRecord = 0;

                this.lowerNote = 0;
                this.upperNote = 0;

                this.regionEnd = new Uint8Array(8);

                this.swavInfoId = new Uint8Array(128);
                this.swarInfoId = new Uint8Array(128);
                this.noteNumber = new Uint8Array(128);
                this.attack = new Uint8Array(128);
                this.decay = new Uint8Array(128);
                this.sustain = new Uint8Array(128);
                this.release = new Uint8Array(128);
                this.pan = new Uint8Array(128);
            }

            resolveEntryIndex(note) {
                switch (this.fRecord) {
                    case InstrumentType.SingleSample:
                    case InstrumentType.PsgPulse:
                    case InstrumentType.PsgNoise:
                        return 0;

                    case InstrumentType.Drumset:
                        if (note < this.lowerNote || note > this.upperNote) {
                            console.warn(`resolveEntryIndex: drumset note out of range (${this.lowerNote}-${this.upperNote} inclusive): ${note}`)
                        }
                        return note - this.lowerNote;

                    case InstrumentType.MultiSample:
                        for (let i = 0; i < 8; i++) {
                            if (note <= this.regionEnd[i]) return i;
                        }
                        return 7;
                }
            }
        }

        // SBNK
        class Bank {
            constructor() {
                /** @type {InstrumentRecord[]} */
                this.instruments = new Array(128);
            }
        }

        class SampleInstrument {
            /**
            * @param {number} sampleRate 
            * @param {Sample} sample
            */
            constructor(sampleRate, sample) {
                this.sampleRate = sampleRate;
                /** @type {Sample} */
                this.sample = sample;

                // sampleFrequency is the sample's tone frequency when played at sampleSampleRate
                this.valL = 0;
                this.valR = 0;
                this.frequency = 440;
                this.volume = 1;

                this.playing = false;
            }

            changeSample(sample) {
                this.sample = sample;
            }

            sampleAt(sample) {
                let ratio = this.frequency / this.sample.frequency;
                let t = sample / this.sampleRate * ratio;
                let sampleSample = Math.round(t * this.sample.sampleRate);

                // if (sampleSample >= this.sample.data.length && this.sample.looping) {
                //     let sampleNoIntro = sampleSample - this.sample.loopPoint;
                //     let loopLength = this.sample.data.length - this.sample.loopPoint;
                //     sampleNoIntro %= loopLength;
                //     sampleSample = sampleNoIntro + this.sample.loopPoint; 
                // }

                if (sampleSample >= 0 && sampleSample < this.sample.data.length) {
                    this.valL = this.sample.data[sampleSample] * this.volume;
                    this.valR = this.sample.data[sampleSample] * this.volume;
                    return true;
                } else {
                    this.valL = 0;
                    this.valR = 0;
                    return false;
                }
            }
        }

        class SseqController {
            /** @param {Array | Uint8Array} sseqFile
             *  @param {number} dataOffset
             *  @param {CircularBuffer} messageBuffer
             **/
            constructor(sseqFile, dataOffset, messageBuffer) {
                this.sseqFile = sseqFile;
                this.dataOffset = dataOffset;
                this.messageBuffer = messageBuffer;

                /** @type {SseqTrack[]} */
                this.tracks = new Array(16);

                for (let i = 0; i < 16; i++) {
                    this.tracks[i] = new SseqTrack(this, i);
                }

                this.tracks[0].active = true;

                this.destroyed = false;
            }

            destroy() {
                this.destroyed = true;
            }

            tick() {
                for (let i = 0; i < 16; i++) {
                    if (this.tracks[i].active) {
                        if (this.tracks[i].restingFor == 0) {
                            while (this.tracks[i].restingFor == 0) {
                                this.tracks[i].execute();
                            }
                        } else {
                            this.tracks[i].restingFor--;
                        }
                    }
                }
            }

            startTrack(num, pc) {
                this.tracks[num].active = true;
                this.tracks[num].pc = pc;
                this.tracks[num].debugLog("Started! PC: " + hexN(pc, 6));
            }

            endTrack(num) {
                this.tracks[num].active = false;
                this.tracks[num].debugLog("Ended track.");
            }
        }

        class SseqTrack {
            constructor(controller, id) {
                /** @type {SseqController} */
                this.controller = controller;
                this.id = id;

                this.active = false;

                this.pc = 0;
                this.pan = 0;
                this.mono = false;
                this.volume = 0;
                this.priority = 0;
                this.program = 0;
                this.bank = 0;

                this.modulationDepth = 0;
                this.modulationSpeed = 0;
                this.modulationType = 0;
                this.modulationRange = 0;

                this.pitchBend = 0;
                this.pitchBendRange = 0;

                this.expression = 0;

                this.portamentoEnable = 0;
                this.portamentoTime = 0;

                this.restingFor = 0;

                this.stack = new Uint32Array(64);
                this.sp = 0;
            }

            debugLog(msg) {
                // console.log(`${this.id}: ${msg}`)
            }

            debugLogForce(msg) {
                console.log(`${this.id}: ${msg}`)
            }

            push(val) {
                this.stack[this.sp++] = val;
                if (this.sp >= this.stack.length) alert("SSEQ stack overflow");
            }

            pop() {
                if (this.sp == 0) alert("SSEQ stack underflow");
                return this.stack[--this.sp];
            }

            readPc() {
                return this.controller.sseqFile[this.pc + this.controller.dataOffset];
            }

            readPcInc(bytes = 1) {
                let val = 0;
                for (let i = 0; i < bytes; i++) {
                    val |= this.readPc() << (i * 8);
                    this.pc++;
                }

                return val;
            }

            readVariableLength(arr, offs) {
                let num = 0;
                for (let i = 0; i < 4; i++) {
                    let val = this.readPcInc();

                    num |= val & 0x7F;
                    num <<= 7;

                    if ((val & 0x80) == 0) {
                        break;
                    }
                }

                return num;
            }

            sendMessage(type, param0, param1, param2) {
                this.controller.messageBuffer.insert(new Message(this.id, type, param0, param1, param2))
            }

            execute() {
                let opcodePc = this.pc;
                let opcode = this.readPcInc();

                if (opcode <= 0x7F) {
                    let velocity = this.readPcInc();
                    let duration = this.readVariableLength();

                    this.debugLog("Note: " + opcode);
                    this.debugLog("Velocity: " + velocity);
                    this.debugLog("Duration: " + duration);

                    this.sendMessage(MessageType.PlayNote, opcode, velocity, duration);
                } else {
                    switch (opcode) {
                        case 0xFE: // Allocate track
                            {
                                // This probably isn't important for emulation
                                let alloced = this.readPcInc(2);

                                for (let i = 0; i < 16; i++) {
                                    if (bitTest(alloced, i)) {
                                        this.debugLog("Allocated track " + i);
                                    }
                                }
                                break;
                            }
                        case 0x93: // Start new track thread 
                            {
                                let trackNum = this.readPcInc();
                                let trackOffs = this.readPcInc(3);

                                this.controller.startTrack(trackNum, trackOffs);

                                this.debugLog("Started track thread " + trackNum);
                                this.debugLog("Offset: " + hex(trackOffs, 6));

                                break;
                            }
                        case 0xC7: // Mono / Poly
                            {
                                let param = this.readPcInc();
                                this.mono = bitTest(param, 0);
                                break;
                            }
                        case 0xCE: // Portamento On / Off
                            {
                                this.portamentoEnable = this.readPcInc();
                                this.debugLog("Portamento On / Off: " + this.portamentoEnable);
                                break;
                            }
                        case 0xCF: // Portamento Time
                            {
                                this.portamentoTime = this.readPcInc();
                                this.debugLog("Portamento Time: " + this.portamentoTime);
                                break;
                            }
                        case 0xE1: // BPM
                            {
                                this.bpm = this.readPcInc(2);
                                this.debugLog("BPM: " + this.bpm);
                                break;
                            }
                        case 0xC1: // Volume
                            {
                                this.volume = this.readPcInc();
                                this.debugLogForce("Volume: " + this.volume);
                                break;
                            }
                        case 0x81: // Set bank and program
                            {
                                let bankAndProgram = this.readVariableLength();
                                this.program = (bankAndProgram >> 7) & 0x7F;
                                this.bank = (bankAndProgram >> 14) & 0x7F;

                                this.debugLogForce(`Bank: ${this.bank} Program: ${this.program}`);

                                this.sendMessage(MessageType.InstrumentChange, this.bank, this.program);
                                break;
                            }
                        case 0xC2: // Master Volume
                            {
                                this.masterVolume = this.readPcInc();
                                this.debugLogForce("Master Volume: " + this.masterVolume);
                                break;
                            }
                        case 0xC0: // Pan
                            {
                                this.pan = this.readPcInc();
                                this.debugLog("Pan: " + this.pan);
                                break;
                            }
                        case 0xC6: // Track Priority
                            {
                                this.priority = this.readPcInc();
                                this.debugLog("Track Priority: " + this.priority);
                                break;
                            }
                        case 0xC5: // Pitch Bend Range
                            {
                                this.pitchBendRange = this.readPcInc();
                                this.debugLog("Pitch Bend Range: " + this.pitchBendRange);
                                break;
                            }
                        case 0xCA: // Modulation Depth
                            {
                                this.modulationDepth = this.readPcInc();
                                this.debugLog("Modulation Depth: " + this.modulationDepth);
                                break;
                            }
                        case 0xCB: // Modulation Speed
                            {
                                this.modulationSpeed = this.readPcInc();
                                this.debugLog("Modulation Speed: " + this.modulationSpeed);
                                break;
                            }
                        case 0xCC: // Modulation Type
                            {
                                this.modulationType = this.readPcInc();
                                this.debugLog("Modulation Type: " + this.modulationType);
                                break;
                            }
                        case 0xCD: // Modulation Range
                            {
                                this.modulationRange = this.readPcInc();
                                this.debugLog("ModulationRange: " + this.modulationRange);
                                break;
                            }
                        case 0xC4: // Pitch Bend
                            {
                                this.pitchBend = this.readPcInc();
                                this.debugLog("Pitch Bend: " + this.pitchBend);
                                break;
                            }
                        case 0x80: // Rest
                            {
                                this.restingFor = this.readVariableLength();
                                this.debugLog("Resting For: " + this.restingFor);
                                break;
                            }
                        case 0x94: // Jump
                            {
                                let dest = this.readPcInc(3);
                                this.pc = dest;
                                this.debugLog("Jump to: " + hexN(dest, 6));
                                break;
                            }
                        case 0x95: // Call
                            {
                                let dest = this.readPcInc(3);

                                // Push the return address
                                this.push(this.pc);
                                this.pc = dest;
                                break;
                            }
                        case 0xFD: // Return
                            {
                                this.pc = this.pop();
                                break;
                            }
                        case 0xB0: // TODO: According to sseq2mid: arithmetic operations?
                            {
                                this.readPcInc(3);
                                break;
                            }
                        case 0xE0: // Modulation Delay
                            {
                                this.modulationDelay = this.readPcInc(2);
                                this.debugLog("Modulation Delay: " + this.modulationDelay);
                                break;
                            }
                        case 0xD5: // Expression
                            {
                                this.expression = this.readPcInc();
                                this.debugLog("Expression: " + this.expression);
                                break;
                            }
                        case 0xFF: // End of Track
                            {
                                this.controller.endTrack(this.id);
                                // Set restingFor to non-zero since the controller checks it to stop executing
                                this.restingFor = 1;
                                break;
                            }
                        default:
                            alert(`${this.id}: Unknown opcode: ` + hex(opcode, 2) + " PC: " + hex(opcodePc, 6));
                    }
                }
            }
        }

        class Synthesizer {
            constructor(sampleRate, instrsAvailable) {
                this.instrsAvailable = instrsAvailable;

                this.instrs = new Array(this.instrsAvailable);
                this.instrsStartSample = new Float64Array(this.instrsAvailable);
                this.sampleNum = 0;
                this.sampleRate = sampleRate;

                this.valL = 0;
                this.valR = 0;

                this.playingIndex = 0;

                let emptySample = new Sample(new Float64Array(1), 440, sampleRate, 0)

                for (let i = 0; i < this.instrs.length; i++) {
                    this.instrs[i] = new SampleInstrument(this.sampleRate, emptySample);
                }
            }

            /**
             * @param {Sample} sample
             * @param {number} frequency
             * @param {number} volume
             */
            play(sample, frequency, volume) {
                this.instrs[this.playingIndex].sample = sample;
                this.instrs[this.playingIndex].playing = true;
                this.instrs[this.playingIndex].frequency = frequency;
                this.instrs[this.playingIndex].volume = volume;
                this.instrsStartSample[this.playingIndex] = this.sampleNum;

                this.playingIndex++;
                this.playingIndex %= this.instrsAvailable;
            }

            nextSample() {
                this.valL = 0;
                this.valR = 0;

                for (let i = 0; i < this.instrsAvailable; i++) {
                    if (this.instrs[i].playing) {
                        this.instrs[i].sampleAt(this.sampleNum - this.instrsStartSample[i]);
                        this.valL += this.instrs[i].valL;
                        this.valR += this.instrs[i].valR;
                    }
                }

                this.sampleNum++;
            }

            getTime() {
                return this.sampleNum / this.sampleRate;
            }
        }

        function bitTest(i, bit) {
            return (i & (1 << bit)) !== 0;
        }

        /** @type {SseqController} */
        let currentlyPlaying = null;
        /** @type {AudioPlayer} */
        let currentPlayer = null;

        /** @type {boolean[]} */
        let enabledTrack = new Array(16).fill(true);

        /**
         * @param {Sdat} sdat
         * @param {string} name
         */
        async function playSeq(sdat, name) {
            if (currentlyPlaying) {
                currentlyPlaying.destroy();
                currentPlayer.ctx.close();
            }

            const BUFFER_SIZE = 16384;
            const SAMPLE_RATE = 32768;

            let sampleFrequency = 440 * 2 ** ((9 - 12) / 12);
            let synthtestSample = decodeWavToSample(await downloadFileFromUrl("synthtest.wav"), sampleFrequency);
            let emptySample = new Sample(new Float64Array(1), 440, SAMPLE_RATE, 0)
            let synthesizer = new Synthesizer(SAMPLE_RATE, 32);

            let id = sdat.sseqNameIdDict[name];
            let info = sdat.sseqInfos[id];
            let bankInfo = sdat.sbnkInfos[info.bank];
            let bank = sdat.banks[info.bank];

            console.log("Playing SSEQ Id:" + id);
            console.log("FAT ID:" + info.fileId);

            let file = sdat.fat[info.fileId];
            let bufferL = new Float32Array(BUFFER_SIZE);
            let bufferR = new Float32Array(BUFFER_SIZE);

            let inBufferPos = 0;

            // // debugging hexdump
            // let offs = 0;
            // for (let i = 0; i < 16; i++) {
            //     let str = "";
            //     for (let j = 0; j < 16; j++) {
            //         str += hexN(file[offs], 2) + " ";
            //         offs++;
            //     }
            //     console.log(str);
            // }
            // console.log(String.fromCharCode(file[0], file[1], file[2], file[3]))

            let dataOffset = read32LE(file, 0x18);
            if (dataOffset != 0x1C) alert("SSEQ offset is not 0x1C? it is: " + hex(dataOffset, 8));

            let messageBuffer = new CircularBuffer(1024);
            let controller = new SseqController(file, dataOffset, messageBuffer);
            currentlyPlaying = controller;


            let timer = 0;
            controller.tick();
            function synthesizeMore() {
                for (let i = 0; i < BUFFER_SIZE; i++) {
                    timer += controller.tracks[0].bpm * 100;
                    while (timer >= SAMPLE_RATE) {
                        timer -= SAMPLE_RATE;

                        // 48 ticks per beat
                        controller.tick();

                        while (messageBuffer.entries > 0) {
                            /** @type {Message} */
                            let msg = messageBuffer.pop();

                            switch (msg.type) {
                                case MessageType.PlayNote:
                                    if (enabledTrack[msg.track]) {
                                        let midiNote = msg.param0;
                                        let hz = 440 * 2 ** ((midiNote - 69) / 12);

                                        // The archive ID inside each instrument record inside each SBNK file
                                        // refers to the archive ID referred to by the corresponding SBNK entry in the INFO block

                                        let instrument = bank.instruments[controller.tracks[msg.track].program];

                                        let index = instrument.resolveEntryIndex(midiNote);
                                        let archiveId = instrument.swarInfoId[index];
                                        let sampleId = instrument.swavInfoId[index];

                                        let archive = sdat.sampleArchives[bankInfo.swarId[archiveId]];
                                        let sample = archive[sampleId];

                                        // if (instrument.fRecord != InstrumentType.Drumset) {
                                            sample.frequency = midiNoteToHz(instrument.noteNumber[index]);
                                        // }

                                        synthesizer.play(sample, hz, msg.param1 / 127 * 1 * (controller.tracks[msg.track].volume / 127));
                                        break;
                                    }
                            }
                        }

                    }

                    // synthesizer.play(440);

                    synthesizer.nextSample();
                    bufferL[i] = synthesizer.valL;
                    bufferR[i] = synthesizer.valR;

                    if (controller.destroyed) {
                        return;
                    }
                }

                // synthesizer.play(Math.random() * 880);
                // synthesizer.play(Math.random() * 880);


                // console.log(inBufferPos);

                player.queueAudio(bufferL, bufferR);

                // console.log("Syntheszing more audio");
            }

            let player = new AudioPlayer(BUFFER_SIZE, SAMPLE_RATE, synthesizeMore);
            currentPlayer = player;
            synthesizeMore();
        }

        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        function decodePcm8(pcm8Data) {
            let out = new Float64Array(pcm8Data.length);

            for (let i = 0; i < out.length; i++) {
                out[i] = (pcm8Data[i] - 127) / 128;
            }

            return out;
        }

        function decodePcm16(pcm16Data) {
            let out = new Float64Array(pcm16Data.length >> 1);

            for (let i = 0; i < out.length; i++) {
                out[i] = ((read16LE(pcm16Data, i * 2) << 16) >> 16) / 32768;
            }

            return out;
        }

        let indexTable = [-1, -1, -1, -1, 2, 4, 6, 8];
        let adpcmTable = [
            0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x0010, 0x0011, 0x0013, 0x0015,
            0x0017, 0x0019, 0x001C, 0x001F, 0x0022, 0x0025, 0x0029, 0x002D, 0x0032, 0x0037, 0x003C, 0x0042,
            0x0049, 0x0050, 0x0058, 0x0061, 0x006B, 0x0076, 0x0082, 0x008F, 0x009D, 0x00AD, 0x00BE, 0x00D1,
            0x00E6, 0x00FD, 0x0117, 0x0133, 0x0151, 0x0173, 0x0198, 0x01C1, 0x01EE, 0x0220, 0x0256, 0x0292,
            0x02D4, 0x031C, 0x036C, 0x03C3, 0x0424, 0x048E, 0x0502, 0x0583, 0x0610, 0x06AB, 0x0756, 0x0812,
            0x08E0, 0x09C3, 0x0ABD, 0x0BD0, 0x0CFF, 0x0E4C, 0x0FBA, 0x114C, 0x1307, 0x14EE, 0x1706, 0x1954,
            0x1BDC, 0x1EA5, 0x21B6, 0x2515, 0x28CA, 0x2CDF, 0x315B, 0x364B, 0x3BB9, 0x41B2, 0x4844, 0x4F7E,
            0x5771, 0x602F, 0x69CE, 0x7462, 0x7FFF
        ];

        // Decodes IMA-ADPCM to PCM16
        function decodeAdpcm(adpcmData) {
            let out = new Float64Array((adpcmData.length - 4) * 2);
            let outOffs = 0;

            let adpcmIndex = 0;

            let header = read32LE(adpcmData, 0);
            // ADPCM header
            let currentValue = header & 0xFFFF;
            adpcmIndex = clamp(header >> 16, 0, 88);

            for (let i = 4; i < adpcmData.length; i++) {
                for (let j = 0; j < 2; j++) {
                    let data = (adpcmData[i] >> (j * 4)) & 0xF;

                    let tableVal = adpcmTable[adpcmIndex];
                    let diff = tableVal >> 3;
                    if ((data & 1) != 0) diff += tableVal >> 2;
                    if ((data & 2) != 0) diff += tableVal >> 1;
                    if ((data & 4) != 0) diff += tableVal >> 0;

                    if ((data & 8) == 8) {
                        currentValue = Math.max(currentValue - diff, -0x7FFF);
                    }
                    else {
                        currentValue = Math.min(currentValue + diff, 0x7FFF);
                    }
                    adpcmIndex = clamp(adpcmIndex + indexTable[data & 7], 0, 88);

                    out[outOffs++] = currentValue / 32768;
                }
            }

            return out;
        }

        /** @param {Uint8Array} wavData */
        function decodeWavToSample(wavData, sampleFrequency) {
            /** @type {number[]} */
            let sampleData = [];

            let numChannels = read16LE(wavData, 22);
            let sampleRate = read32LE(wavData, 24);
            let bitsPerSample = read16LE(wavData, 34);

            console.log("decodeWav: sample rate: " + sampleRate);

            switch (bitsPerSample) {
                case 8:
                case 16:
                    break;
                default:
                    console.error("decodeWav: unsupported bits per sample: " + bitsPerSample);
                    return;
            }

            // Number of bytes in the wav data
            let subchunk2Size = read32LE(wavData, 40);


            for (let i = 44; i < 44 + subchunk2Size; i += bitsPerSample / 8 * numChannels) {
                switch (bitsPerSample) {
                    case 8:
                        sampleData.push(wavData[i] / 255);
                        break;
                    case 16:
                        sampleData.push(((read16LE(wavData, i) << 16) >> 16) / 32767);
                        break;
                }
            }

            return new Sample(Float64Array.from(sampleData), sampleFrequency, sampleRate);
        }

        function playStrm(strmData) {
            const BUFFER_SIZE = 4096;
            const SAMPLE_RATE = 32768;

            let bufferL = new Float32Array(BUFFER_SIZE);
            let bufferR = new Float32Array(BUFFER_SIZE);

            console.log("Number of Samples: " + read32LE(strmData, 0x24));

            let channels = strmData[0x1A];
            let numberOfBlocks = read32LE(strmData, 0x2C);
            let blockLength = read32LE(strmData, 0x30);
            let samplesPerBlock = read32LE(strmData, 0x34);
            let lastBlockLength = read32LE(strmData, 0x38);
            let lastBlockSamples = read32LE(strmData, 0x3C);

            console.log("Channels: " + channels)
            console.log("Number of blocks per channel: " + numberOfBlocks);
            console.log("Block length: " + blockLength)
            console.log("Samples per block: " + samplesPerBlock)
            console.log("Last block length: " + lastBlockLength)
            console.log("Last block samples: " + lastBlockSamples)

            if (numberOfBlocks > 2) alert("TODO: Support for block counts other than 2");
            if (channels < 2) alert("TODO: Support for mono audio");

            let sampleRate = read16LE(strmData, 0x1C);
            console.log("Sample Rate: " + sampleRate);
            console.log("Time: " + read16LE(strmData, 0x1E));

            let waveDataSize = blockLength;

            console.log("Wave data size: " + waveDataSize)

            let waveDataL = new Uint8Array(waveDataSize);
            let waveDataR = new Uint8Array(waveDataSize);

            for (let i = 0; i < waveDataSize; i++) {
                waveDataL[i] = strmData[0x68 + i];
                waveDataR[i] = strmData[0x68 + blockLength + i];
            }

            let decodedL;
            let decodedR;
            let format;
            switch (strmData[0x18]) {
                case 0: format = "PCM8"; break;
                case 1:
                    format = "PCM16";
                    decodedL = decodePcm16(waveDataL);
                    decodedR = decodePcm16(waveDataR);
                    break;
                case 2:
                    format = "IMA-ADPCM";
                    break;
            }

            console.log("Format: " + format);

            let inBufferPos = 0;
            let timer = 0;

            function synthesizeMore() {
                for (let i = 0; i < BUFFER_SIZE; i++) {
                    bufferL[i] = decodedL[inBufferPos];
                    bufferR[i] = decodedR[inBufferPos];

                    timer += sampleRate;
                    if (timer >= SAMPLE_RATE) {
                        timer -= SAMPLE_RATE;
                        if (++inBufferPos >= decodedL.length) {
                            inBufferPos = 0;
                        }
                    }
                }

                // console.log(inBufferPos);

                player.queueAudio(bufferL, bufferR);

                // console.log("Syntheszing more audio");
            }

            let player = new AudioPlayer(BUFFER_SIZE, SAMPLE_RATE, synthesizeMore);
            synthesizeMore();
        }

        /** 
         * @param {Sample} sample 
         * */
        function playSample(sample) {
            return new Promise((resolve, reject) => {
                const BUFFER_SIZE = 4096;
                const SAMPLE_RATE = sample.sampleRate;

                let bufferL = new Float32Array(BUFFER_SIZE);
                let bufferR = new Float32Array(BUFFER_SIZE);

                let inBufferPos = 0;
                let timer = 0;

                function synthesizeMore() {

                    let ended = false;

                    for (let i = 0; i < BUFFER_SIZE; i++) {
                        if (inBufferPos >= sample.data.length) {
                            ended = true;
                            bufferL[i] = 0;
                            bufferR[i] = 0;
                        } else {
                            bufferL[i] = sample.data[inBufferPos];
                            bufferR[i] = sample.data[inBufferPos];
                        }

                        timer += sample.sampleRate;
                        if (timer >= SAMPLE_RATE) {
                            timer -= SAMPLE_RATE;

                            inBufferPos++;
                        }
                    }

                    if (ended) {
                        resolve();
                        return;
                    }

                    player.queueAudio(bufferL, bufferR);

                }

                let player = new AudioPlayer(BUFFER_SIZE, SAMPLE_RATE, synthesizeMore);
                synthesizeMore();
                console.log("start");
            })
        }

        function midiNoteToHz(note) {
            return 440 * 2 ** ((note - 69) / 12);
        }

        function loadSdatFromRom(data, offset) {
            let sdat = new Sdat();

            let sdatSize = read32LE(data, offset + 0x8);
            console.log("SDAT file size: " + sdatSize);

            let sdatData = new Uint8Array(sdatSize);

            for (let i = 0; i < sdatSize; i++) {
                sdatData[i] = data[offset + i];
            }

            let numOfBlocks = read16LE(sdatData, 0xE);
            let headerSize = read16LE(sdatData, 0xC);

            console.log("Number of Blocks: " + numOfBlocks);
            console.log("Header Size: " + headerSize);

            if (headerSize > 256) {
                console.log("Header size too big (> 256), rejecting.");
                return;
            }

            let symbOffs = read32LE(sdatData, 0x10);
            let symbSize = read32LE(sdatData, 0x14);
            let infoOffs = read32LE(sdatData, 0x18);
            let infoSize = read32LE(sdatData, 0x1C);
            let fatOffs = read32LE(sdatData, 0x20);
            let fatSize = read32LE(sdatData, 0x24);
            let fileOffs = read32LE(sdatData, 0x28);
            let fileSize = read32LE(sdatData, 0x2C);

            console.log("SYMB Block Offset: " + hexN(symbOffs, 8));
            console.log("SYMB Block Size: " + hexN(symbSize, 8));
            console.log("INFO Block Offset: " + hexN(infoOffs, 8));
            console.log("INFO Block Size: " + hexN(infoSize, 8));
            console.log("FAT  Block Offset: " + hexN(fatOffs, 8));
            console.log("FAT  Block Size: " + hexN(fatSize, 8));
            console.log("FILE Block Offset: " + hexN(fileOffs, 8));
            console.log("FILE Block Size: " + hexN(fileSize, 8));

            // SYMB processing
            {
                // SSEQ symbols
                let symbSseqListOffs = read32LE(sdatData, symbOffs + 0x8);
                let symbSseqListNumEntries = read32LE(sdatData, symbOffs + symbSseqListOffs);

                console.log("SYMB Bank List Offset: " + hexN(symbSseqListOffs, 8));
                console.log("SYMB Number of SSEQ entries: " + symbSseqListNumEntries);

                for (let i = 0; i < symbSseqListNumEntries; i++) {
                    let sseqNameOffs = read32LE(sdatData, symbOffs + symbSseqListOffs + 4 + i * 4);

                    let sseqNameArr = [];
                    let sseqNameCharOffs = 0;
                    while (true) {
                        let char = sdatData[symbOffs + sseqNameOffs + sseqNameCharOffs];
                        if (char == 0) break; // check for null terminator
                        sseqNameCharOffs++;
                        sseqNameArr.push(char);
                    }

                    // for some reason games have a ton of empty symbols
                    if (sseqNameOffs != 0) {
                        let seqName = String.fromCharCode(...sseqNameArr);

                        sdat.sseqNameIdDict[seqName] = i;
                        sdat.sseqIdNameDict[i] = seqName;
                    }
                }
            }

            {
                // SSAR symbols
                let symbSsarListOffs = read32LE(sdatData, symbOffs + 0xC);
                let symbSsarListNumEntries = read32LE(sdatData, symbOffs + symbSsarListOffs);

                console.log("SYMB Number of SSAR entries: " + symbSsarListNumEntries);
            }

            {
                // BANK symbols
                let symbBankListOffs = read32LE(sdatData, symbOffs + 0x10);
                let symbBankListNumEntries = read32LE(sdatData, symbOffs + symbBankListOffs);

                console.log("SYMB Bank List Offset: " + hexN(symbBankListOffs, 8));
                console.log("SYMB Number of BANK entries: " + symbBankListNumEntries);

                for (let i = 0; i < symbBankListNumEntries; i++) {
                    let symbNameOffs = read32LE(sdatData, symbOffs + symbBankListOffs + 4 + i * 4);
                    if (i == 0) console.log("NDS file addr of BANK list 1st entry: " + hexN(offset + symbOffs + symbNameOffs, 8));

                    let bankNameArr = [];
                    let bankNameCharOffs = 0;
                    while (true) {
                        let char = sdatData[symbOffs + symbNameOffs + bankNameCharOffs];
                        if (char == 0) break; // check for null terminator
                        bankNameCharOffs++;
                        bankNameArr.push(char);
                    }

                    // for some reason games have a ton of empty symbols
                    if (symbNameOffs != 0) {
                        let bankName = String.fromCharCode(...bankNameArr);

                        console.log(bankName)
                        sdat.sbnkNameIdDict[bankName] = i;
                        sdat.sbnkIdNameDict[i] = bankName;
                    }
                }
            }

            {
                // SWAR symbols
                let symbSwarListOffs = read32LE(sdatData, symbOffs + 0x14);
                let symbSwarListNumEntries = read32LE(sdatData, symbOffs + symbSwarListOffs);

                console.log("SYMB Number of SWAR entries: " + symbSwarListNumEntries);
            }

            // INFO processing
            {
                // SSEQ info
                let infoSseqListOffs = read32LE(sdatData, infoOffs + 0x8);
                let infoSseqListNumEntries = read32LE(sdatData, infoOffs + infoSseqListOffs);
                console.log("INFO Number of SSEQ entries: " + infoSseqListNumEntries);

                for (let i = 0; i < infoSseqListNumEntries; i++) {
                    let infoSseqNameOffs = read32LE(sdatData, infoOffs + infoSseqListOffs + 4 + i * 4);

                    if (infoSseqNameOffs != 0) {
                        let info = new SseqInfo();
                        info.fileId = read16LE(sdatData, infoOffs + infoSseqNameOffs + 0);
                        info.bank = read16LE(sdatData, infoOffs + infoSseqNameOffs + 4);
                        info.volume = sdatData[infoOffs + infoSseqNameOffs + 6];
                        info.cpr = sdatData[infoOffs + infoSseqNameOffs + 7];
                        info.ppr = sdatData[infoOffs + infoSseqNameOffs + 8];
                        info.ply = sdatData[infoOffs + infoSseqNameOffs + 9];

                        sdat.sseqInfos[i] = info;
                    } else {
                        sdat.sseqInfos[i] = null;
                    }
                }
            }

            {
                // SSAR info
                let infoSsarListOffs = read32LE(sdatData, infoOffs + 0xC);
                let infoSsarListNumEntries = read32LE(sdatData, infoOffs + infoSsarListOffs);
                console.log("INFO Number of SSAR entries: " + infoSsarListNumEntries);

                for (let i = 0; i < infoSsarListNumEntries; i++) {
                    let infoSsarNameOffs = read32LE(sdatData, infoOffs + infoSsarListOffs + 4 + i * 4);

                    if (infoSsarNameOffs != 0) {
                        let info = new SsarInfo();
                        info.fileId = read16LE(sdatData, infoOffs + infoSsarNameOffs + 0);

                        sdat.ssarInfos[i] = info;
                    } else {
                        sdat.ssarInfos[i] = null;
                    }
                }
            }

            {
                // BANK info
                let infoBankListOffs = read32LE(sdatData, infoOffs + 0x10);
                let infoBankListNumEntries = read32LE(sdatData, infoOffs + infoBankListOffs);
                console.log("INFO Number of BANK entries: " + infoBankListNumEntries);

                for (let i = 0; i < infoBankListNumEntries; i++) {
                    let infoBankNameOffs = read32LE(sdatData, infoOffs + infoBankListOffs + 4 + i * 4);

                    if (infoBankNameOffs != 0) {
                        let info = new BankInfo();
                        info.fileId = read16LE(sdatData, infoOffs + infoBankNameOffs + 0x0);
                        info.swarId[0] = read16LE(sdatData, infoOffs + infoBankNameOffs + 0x4);
                        info.swarId[1] = read16LE(sdatData, infoOffs + infoBankNameOffs + 0x6);
                        info.swarId[2] = read16LE(sdatData, infoOffs + infoBankNameOffs + 0x8);
                        info.swarId[3] = read16LE(sdatData, infoOffs + infoBankNameOffs + 0xA);

                        sdat.sbnkInfos[i] = info;
                    } else {
                        sdat.sbnkInfos[i] = null;
                    }
                }
            }

            {
                // SWAR info
                let infoSwarListOffs = read32LE(sdatData, infoOffs + 0x14);
                let infoSwarListNumEntries = read32LE(sdatData, infoOffs + infoSwarListOffs);
                console.log("INFO Number of SWAR entries: " + infoSwarListNumEntries);

                for (let i = 0; i < infoSwarListNumEntries; i++) {
                    let infoSwarNameOffs = read32LE(sdatData, infoOffs + infoSwarListOffs + 4 + i * 4);

                    if (infoSwarNameOffs) {
                        let info = new SwarInfo();
                        info.fileId = read16LE(sdatData, infoOffs + infoSwarNameOffs + 0x0);

                        sdat.swarInfos[i] = info;
                    } else {
                        sdat.swarInfos[i] = null;
                    }
                }
            }

            // FAT / FILE processing
            let fatNumFiles = read32LE(sdatData, fatOffs + 8);
            console.log("FAT Number of files: " + fatNumFiles);

            for (let i = 0; i < fatNumFiles; i++) {
                let fileEntryOffs = fatOffs + 0xC + i * 0x10;

                let fileDataOffs = read32LE(sdatData, fileEntryOffs);
                let fileSize = read32LE(sdatData, fileEntryOffs + 4);

                let fileData = new Uint8Array(fileSize);

                for (let j = 0; j < fileSize; j++) {
                    fileData[j] = sdatData[fileDataOffs + j];
                }

                sdat.fat[i] = fileData;

                // console.log(`Loaded FAT file id:${i} size:${fileSize}`);
            }

            // Decode sound banks
            console.log(sdat.sbnkInfos)
            for (let i = 0; i < sdat.sbnkInfos.length; i++) {
                let bank = new Bank();

                let bankInfo = sdat.sbnkInfos[i];

                if (bankInfo != null) {
                    let bankFile = sdat.fat[bankInfo.fileId];

                    let numberOfInstruments = read32LE(bankFile, 0x38);
                    console.log(`Bank ${i} / ${sdat.sbnkIdNameDict[i]}: ${numberOfInstruments} instruments`);
                    for (let j = 0; j < numberOfInstruments; j++) {
                        let fRecord = bankFile[0x3C + j * 4 + 0];
                        let recordOffset = read16LE(bankFile, 0x3C + j * 4 + 1);

                        let instrument = new InstrumentRecord();
                        instrument.fRecord = fRecord;

                        switch (fRecord) {
                            case 0: // Empty
                                break;

                            case InstrumentType.SingleSample: // Sample
                            case InstrumentType.PsgPulse: // PSG Pulse
                            case InstrumentType.PsgNoise: // PSG Noise
                                instrument.swavInfoId[0] = read16LE(bankFile, recordOffset + 0x0);
                                instrument.swarInfoId[0] = read16LE(bankFile, recordOffset + 0x2);
                                instrument.noteNumber[0] = bankFile[recordOffset + 0x4];
                                instrument.attack[0] = bankFile[recordOffset + 0x5];
                                instrument.decay[0] = bankFile[recordOffset + 0x6];
                                instrument.sustain[0] = bankFile[recordOffset + 0x7];
                                instrument.release[0] = bankFile[recordOffset + 0x8];
                                instrument.pan[0] = bankFile[recordOffset + 0x9];
                                break;

                            case InstrumentType.Drumset: // Drumset 
                                {
                                    let instrumentCount = bankFile[recordOffset + 1] - bankFile[recordOffset] + 1;

                                    instrument.lowerNote = bankFile[recordOffset + 0];
                                    instrument.upperNote = bankFile[recordOffset + 1];

                                    for (let k = 0; k < instrumentCount; k++) {
                                        instrument.swavInfoId[k] = read16LE(bankFile, recordOffset + 4 + k * 12 + 0x0);
                                        instrument.swarInfoId[k] = read16LE(bankFile, recordOffset + 4 + k * 12 + 0x2);
                                        instrument.noteNumber[k] = bankFile[recordOffset + 4 + k * 12 + 0x4];
                                        instrument.attack[k] = bankFile[recordOffset + 4 + k * 12 + 0x5];
                                        instrument.decay[k] = bankFile[recordOffset + 4 + k * 12 + 0x6];
                                        instrument.sustain[k] = bankFile[recordOffset + 4 + k * 12 + 0x7];
                                        instrument.release[k] = bankFile[recordOffset + 4 + k * 12 + 0x8];
                                        instrument.pan[k] = bankFile[recordOffset + 4 + k * 12 + 0x9];
                                    }
                                    break;
                                }
                            case InstrumentType.MultiSample: // Multi-Sample Instrument
                                {
                                    let instrumentCount = 0;
                                    for (let k = 0; k < 8; k++) {
                                        let end = bankFile[recordOffset + k];
                                        instrument.regionEnd[k] = end;
                                        if (end == 0x7F) {
                                            instrumentCount = k + 1;
                                            break;
                                        }
                                    }

                                    for (let k = 0; k < instrumentCount; k++) {
                                        instrument.swavInfoId[k] = read16LE(bankFile, recordOffset + 10 + k * 12 + 0x0);
                                        instrument.swarInfoId[k] = read16LE(bankFile, recordOffset + 10 + k * 12 + 0x2);
                                        instrument.noteNumber[k] = bankFile[recordOffset + 10 + k * 12 + 0x4];
                                        instrument.attack[k] = bankFile[recordOffset + 10 + k * 12 + 0x5];
                                        instrument.decay[k] = bankFile[recordOffset + 10 + k * 12 + 0x6];
                                        instrument.sustain[k] = bankFile[recordOffset + 10 + k * 12 + 0x7];
                                        instrument.release[k] = bankFile[recordOffset + 10 + k * 12 + 0x8];
                                        instrument.pan[k] = bankFile[recordOffset + 10 + k * 12 + 0x9];
                                    }
                                    break;
                                }

                            default:
                                console.warn(`Instrument ${j}: Invalid fRecord: ${fRecord} Offset:${recordOffset}`);
                                break;
                        }

                        bank.instruments[j] = instrument;
                    }

                    sdat.banks[i] = bank;
                }
            }

            // Decode sample archives
            for (let i = 0; i < sdat.swarInfos.length; i++) {
                let archive = [];

                let swarInfo = sdat.swarInfos[i];
                if (swarInfo != null) {
                    let swarFile = sdat.fat[swarInfo.fileId];

                    let sampleCount = read32LE(swarFile, 0x38);
                    for (let j = 0; j < sampleCount; j++) {
                        let sampleOffset = read32LE(swarFile, 0x3C + j * 4);

                        let wavType = swarFile[sampleOffset + 0];
                        let loopFlag = swarFile[sampleOffset + 1];
                        let sampleRate = read16LE(swarFile, sampleOffset + 2);
                        let swarLoopOffset = read16LE(swarFile, sampleOffset + 6); // in 4-byte units
                        let swarSampleLength = read32LE(swarFile, sampleOffset + 8); // in 4-byte units (excluding ADPCM header if any)

                        let sampleDataLength = (swarLoopOffset + swarSampleLength) * 4;

                        // add 4 byte ADPCM header to length
                        if (wavType == 2) {
                            sampleDataLength += 4;
                        }

                        let sampleData = new Uint8Array(sampleDataLength);
                        for (let k = 0; k < sampleDataLength; k++) {
                            sampleData[k] = swarFile[sampleOffset + k + 0xC];
                        }

                        let decoded;
                        let loopLength = 0;

                        switch (wavType) {
                            case 0: // PCM8
                                loopLength = swarLoopOffset * 4;
                                decoded = decodePcm8(sampleData);
                                console.log(`Archive ${i}, Sample ${j}: PCM8`);
                                break;
                            case 1: // PCM16
                                loopLength = swarLoopOffset * 2;
                                decoded = decodePcm16(sampleData);
                                console.log(`Archive ${i}, Sample ${j}: PCM16`);
                                break;
                            case 2: // IMA-ADPCM
                                loopLength = swarLoopOffset * 8 - 8; // subtract ADPCM header
                                decoded = decodeAdpcm(sampleData);
                                console.log(`Archive ${i}, Sample ${j}: ADPCM`);
                                break;
                        }

                        archive[j] = new Sample(decoded, 440, sampleRate, loopFlag != 0, loopLength);
                        archive[j].sampleLength = swarSampleLength * 4;
                    }

                    sdat.sampleArchives[i] = archive;
                }
            }

            window.sdat = sdat;

            return sdat;
        }

        function searchForSequences(data, sequence) {
            let seqs = [];

            for (let i = 0; i < data.length; i++) {
                if (data[i] == sequence[0]) {
                    for (let j = 1; j < sequence.length; j++) {
                        if (data[i + j] != sequence[j]) {
                            break;
                        }

                        if (j == sequence.length - 1) seqs.push(i);
                    }
                }
            }

            return seqs;
        }

        function downloadFileFromUrl(url) {
            return new Promise((resolve, reject) => {
                let client = new XMLHttpRequest();
                client.responseType = "arraybuffer";
                client.open("GET", url);
                client.onreadystatechange = () => {
                    if (client.status != 404) {
                        if (client.response instanceof ArrayBuffer) {
                            resolve(new Uint8Array(client.response));
                            return;
                        }
                    } else {
                        reject();
                        return;
                    }
                };
                client.send();
            });
        }

        async function loadNdsRom(data) {
            console.log(`ROM size: ${data.length} bytes`);

            let sequence = [0x53, 0x44, 0x41, 0x54, 0xFF, 0xFE, 0x00, 0x01]; // "SDAT", then byte order 0xFEFF, then version 0x0100
            let res = searchForSequences(data, sequence);
            if (res.length > 0) {
                console.log(`Found SDATs at:`);
                for (let i = 0; i < res.length; i++) {
                    console.log(hex(res[i], 8));
                }
            } else {
                console.log(`Couldn't find SDAT (maybe not an NDS ROM?)`);
            }

            for (let i = 0; i < res.length; i++) {
                let sdat = loadSdatFromRom(data, res[i]);

                if (sdat != null) {
                    for (let i = 0; i < sdat.sseqIdNameDict.length; i++) {
                        let seqName = sdat.sseqIdNameDict[i];
                        if (seqName != undefined) {
                            let button = document.createElement('button');
                            button.innerText = `ID: ${i} ${seqName}`;
                            button.style.textAlign = 'left';
                            document.querySelector(".song-picker").appendChild(button);
                            button.onclick = () => {
                                console.log(seqName);
                                playSeq(sdat, seqName);
                            }
                        }
                    }

                    console.log("Searching for STRMs")
                    for (let i = 0; i < sdat.fat.length; i++) {
                        if (read32LE(sdat.fat[i], 0) == 0x4D525453) {
                            console.log(`file id:${i} is STRM`);

                            playStrm(sdat.fat[i]);
                        }
                    }

                    // for (let i = 0; i < sdat.sampleArchives.length; i++) {
                    //     let archive = sdat.sampleArchives[i];
                    //     for (let j = 0; j < archive.length; j++) {
                    //         let sample = archive[j];

                    //         console.log(`Playing archive ${i}, sample ${j}, length ${sample.data.length / sample.sampleRate} seconds`)

                    //         await playSample(sample);
                    //     }
                    // }
                    // console.log("Done playing samples");
                }
            }

            /** @type {HTMLElement} */
            let filePickerContainer = document.querySelector("#file-picker-container")
            filePickerContainer.style.display = 'none';

            /** @type {HTMLDivElement} */
            let channelsDiv = document.querySelector(".channels");
            channelsDiv.style.display = 'block';
        }

        window.onload = async () => {
            console.log("Optime Player");

            /** @type {HTMLElement} */
            let dropZone = document.querySelector('#drop-zone');
            /** @type {HTMLInputElement} */
            let filePicker = document.querySelector('#file-picker');
            /** @type {HTMLDivElement} */
            let channelsDiv = document.querySelector(".channels");
            channelsDiv.style.display = 'none';

            dropZone.style.visibility = 'hidden';
            window.addEventListener('dragover', e => {
                e.preventDefault();
                // console.log("File dragged over");
                dropZone.style.visibility = 'visible';
            });
            dropZone.addEventListener('dragleave', e => {
                e.preventDefault();
                // console.log("File drag leave");
                dropZone.style.visibility = 'hidden';
            });
            window.addEventListener('drop', e => {
                e.preventDefault();
                if (e.dataTransfer.files[0] instanceof Blob) {
                    console.log("File dropped");

                    dropZone.style.visibility = 'hidden';

                    let reader = new FileReader();
                    reader.onload = function () {
                        if (this.result instanceof ArrayBuffer) {
                            loadNdsRom(new Uint8Array(this.result));
                        }
                    }
                    reader.readAsArrayBuffer(e.dataTransfer.files[0]);
                }
            });

            filePicker.addEventListener("input", () => {
                if (filePicker.files && filePicker.files.length > 0) {
                    let file = filePicker.files[0];
                    let reader = new FileReader();
                    reader.readAsArrayBuffer(file);
                    reader.onload = function () {
                        let result = reader.result;
                        if (result instanceof ArrayBuffer) {
                            loadNdsRom(new Uint8Array(result));
                        } else {
                            alert("Failed to read file! Probably a result of a lack of API support.");
                        }
                    };
                }
            });

            for (let i = 0; i < 16; i++) {
                let channelDiv = document.createElement('div');
                channelsDiv.append(channelDiv);
                let label = document.createElement("label");
                label.innerText = `Channel ${i}`
                label.htmlFor = `channel-select-checkbox${i}`;
                label.id = `channel-select-label${i}`
                let input = document.createElement("input");
                input.type = 'checkbox';
                input.checked = true;
                input.id = `channel-select-checkbox${i}`;
                channelDiv.append(label);
                channelDiv.append(input);

                input.onchange = e => {
                    enabledTrack[i] = input.checked;
                };

            }
        }
    </script>
</head>

<body>
    <div id='drop-zone'>
        <h1>Drop file!</h1>
    </div>
    <h1>Optime Player</h1>

    <div id="file-picker-container">
        <h3>Drag and drop a Nintendo DS ROM</h3>
        <p>or</p>
        <input type="file" id="file-picker" accept=".nds">
    </div>

    <div class="container">
        <div class="song-picker"></div>
        <div class="channels"></div>
    </div>
</body>

</html>