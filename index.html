<html>

<head>
    <title>Optime Player</title>

    <style>
        @font-face {
            font-family: HindSiliguri;
            src: url('fonts/HindSiliguri-Regular.ttf');
        }

        body {
            font-family: HindSiliguri;

            text-align: center;
        }

        #drop-zone {
            display: flex;
            align-items: center;
            justify-content: center;

            /* display: none; */

            background: gray;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            opacity: .8;

            font-size: 32px;

            visibility: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 0.7fr 1.5fr 0.8fr;
            grid-template-rows: 0.7fr 1.3fr 1fr;
            gap: 0px 0px;
            grid-template-areas:
                "song-picker . ."
                "song-picker channels ."
                "song-picker . .";
        }

        .song-picker {
            grid-area: song-picker;

            display: flex;
            flex-direction: column;
        }

        .channels {
            grid-area: channels;
        }
    </style>

    <script>
        //@ts-check
        class AudioPlayer {
            bufferLength;
            sampleRate;
            needMoreSamples;

            bufferPool;
            bufferPoolAt = 0;

            safariHax = false;

            constructor(bufferLength, sampleRate, needMoreSamples) {
                if (!AudioBuffer.prototype.copyToChannel) this.safariHax = true;

                this.bufferLength = bufferLength;
                this.sampleRate = sampleRate;
                this.needMoreSamples = needMoreSamples;

                const AudioContext = window.AudioContext   // Normal browsers
                    //@ts-ignore
                    || window.webkitAudioContext; // Sigh... Safari

                this.ctx = new AudioContext({ sampleRate: sampleRate });

                this.bufferPool = this.genBufferPool(256, this.bufferLength);

                const fixAudioContext = () => {
                    // Create empty buffer
                    let buffer = this.ctx.createBuffer(1, 1, 22050);
                    let source = this.ctx.createBufferSource();
                    source.buffer = buffer;
                    // Connect to output (speakers)
                    source.connect(this.ctx.destination);
                    // Play sound
                    if (source.start) {
                        source.start(0);
                    } else if (source.play) {
                        source.play(0);
                    } else if (source.noteOn) {
                        source.noteOn(0);
                    }
                };
                // iOS 6-8
                document.addEventListener('touchstart', fixAudioContext);
                // iOS 9
                document.addEventListener('touchend', fixAudioContext);

                this.gain = this.ctx.createGain();
                this.gain.gain.value = 0.25;
                this.gain.connect(this.ctx.destination);
            }

            gain;

            ctx;
            sourcesPlaying = 0;

            genBufferPool(count, length) {
                let pool = new Array(count);
                for (let i = 0; i < count; i++) {
                    pool[i] = this.ctx.createBuffer(2, length, this.sampleRate);
                }
                return pool;
            }

            queueAudio(bufferLeft, bufferRight) {
                let buffer = this.bufferPool[this.bufferPoolAt];
                this.bufferPoolAt++;
                this.bufferPoolAt &= 255;

                if (!this.safariHax) {
                    buffer.copyToChannel(bufferLeft, 0);
                    buffer.copyToChannel(bufferRight, 1);
                } else {
                    buffer.getChannelData(0).set(bufferLeft);
                    buffer.getChannelData(1).set(bufferRight);
                }

                let bufferSource = this.ctx.createBufferSource();

                bufferSource.onended = () => {
                    this.sourcesPlaying--;
                    if (this.sourcesPlaying < 3) {
                        this.needMoreSamples();
                    }
                    if (this.sourcesPlaying < 2) {
                        this.needMoreSamples();
                    }
                };

                // if (this.audioSec <= this.ctx.currentTime + 0.05) {
                // Reset time if close to buffer underrun
                // this.audioSec = this.ctx.currentTime + 0.06;
                // }
                bufferSource.buffer = buffer;
                bufferSource.connect(this.gain);
                bufferSource.start(this.audioSec);

                this.sampleRate = this.sampleRate;
                this.audioSec += this.bufferLength / this.sampleRate;

                this.sourcesPlaying++;
            }

            audioSec = 0;

            reset() {
                // 50 ms buffer
                this.audioSec = this.ctx.currentTime + 0.06;
                // console.log(`Latency in seconds: ${(LATENCY / this.sampleRate)}`)
            }
        }

        function read16LE(data, addr) {
            return data[addr] | (data[addr + 1] << 8);
        }

        function read32LE(data, addr) {
            return data[addr] | (data[addr + 1] << 8) | (data[addr + 2] << 16) | (data[addr + 3] << 24);
        }

        function pad(n, width, z) {
            z = z || '0';
            n = n + '';
            return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
        }

        function hex(i, digits) {
            return `0x${pad(i.toString(16), digits, '0').toUpperCase()}`;
        }

        function hexN(i, digits) {
            return pad(i.toString(16), digits, '0').toUpperCase();
        }

        class CircularBuffer {
            /** @param {number} size */
            constructor(size) {
                this.size = size;
                this.buffer = new Array(size);

                this.entries = 0;
                this.readPos = 0;
                this.writePos = 0;
            }

            insert(data) {
                if (this.entries < this.size) {
                    this.entries++;
                    this.buffer[this.writePos++] = data;

                    if (this.writePos >= this.size) {
                        this.writePos = 0;
                    }

                    return true;
                }

                alert("CircularBuffer: overflow");

                return false;
            }

            pop() {
                let data;
                if (this.entries > 0) {
                    this.entries--;
                    data = this.buffer[this.readPos++];

                    if (this.readPos >= this.size) {
                        this.readPos = 0;
                    }
                }
                else {
                    alert("CircularBuffer: underflow");
                    data = null;
                }
                return data;
            }

            peek(offset) {
                return this.buffer[(this.readPos + offset) % this.size];
            }

            reset() {
                this.entries = 0;
                this.readPos = 0;
                this.writePos = 0;
            }
        }


        class SseqInfo {
            constructor() {
                this.fileId = null;
                this.bank = null;
                this.volume = null;
                this.cpr = null;
                this.ppr = null;
                this.ply = null;
            }
        }

        class Sdat {
            constructor() {
                this.fat = [];
                this.sseqInfos = [];
                this.sseqNameIdDict = [];
                this.sseqIdNameDict = [];
            }
        }

        class Message {
            constructor(type, param0, param1, param2) {
                this.type = type;
                this.param0 = param0;
                this.param1 = param1;
                this.param2 = param2;
            }
        }

        const MessageType = {
            PlayNote: 0,
        }

        class PsgSquareInstrument {
            constructor(sampleRate) {
                this.valL = 0;
                this.valR = 0;
                this.frequency = 440;
                this.sampleRate = sampleRate;
                this.volume = 1;

                this.playing = false;
            }

            sampleAt(sample) {
                let t = sample / this.sampleRate;

                let continuePlaying = true;

                // TODO: a better envelope
                let envVol = 0;
                if (t < 0.4) {
                    envVol = 1 - t / 0.4;
                } else {
                    envVol = 0;
                    continuePlaying = false;
                }

                let periodTime = 1 / this.frequency;

                if ((t % periodTime) >= periodTime / 2) {
                    this.valL = this.volume * envVol;
                    this.valR = this.volume * envVol;
                } else {
                    this.valL = -this.volume * envVol;
                    this.valR = -this.volume * envVol;
                }

                return continuePlaying;
            }
        }

        class Sample {
            /**
            * @param {Float64Array} data 
            * @param {number} frequency
            * @param {number} sampleRate
            */
            constructor(data, frequency, sampleRate) {
                this.data = data;
                this.frequency = frequency;
                this.sampleRate = sampleRate;
            }
        }

        class SampleInstrument {
            /**
            * @param {number} sampleRate 
            * @param {Sample} sample
            */
            constructor(sampleRate, sample) {
                this.sampleRate = sampleRate;
                this.sample = sample;

                // sampleFrequency is the sample's tone frequency when played at sampleSampleRate
                this.valL = 0;
                this.valR = 0;
                this.frequency = 440;
                this.volume = 1;

                this.playing = false;
            }

            sampleAt(sample) {
                let ratio = this.frequency / this.sample.frequency;
                let t = sample / this.sampleRate * ratio;
                let sampleSample = Math.round(t * this.sample.sampleRate);

                if (sampleSample >= 0 && sampleSample < this.sample.data.length) {
                    this.valL = this.sample.data[sampleSample];
                    this.valR = this.sample.data[sampleSample];
                    return true;
                } else {
                    this.valL = 0;
                    this.valR = 0;
                    return false;
                }
            }
        }

        class SseqController {
            /** @param {Array} sseqFile
             *  @param {number} dataOffset
             *  @param {CircularBuffer} messageBuffer
             **/
            constructor(sseqFile, dataOffset, messageBuffer) {
                this.sseqFile = sseqFile;
                this.dataOffset = dataOffset;
                this.messageBuffer = messageBuffer;

                /** @type {SseqTrack[]} */
                this.tracks = new Array(16);

                for (let i = 0; i < 16; i++) {
                    this.tracks[i] = new SseqTrack(this, i);
                }

                this.tracks[0].active = true;

                this.destroyed = false;
            }

            destroy() {
                this.destroyed = true;
            }

            tick() {
                for (let i = 0; i < 16; i++) {
                    if (this.tracks[i].active) {
                        if (this.tracks[i].restingFor == 0) {
                            while (this.tracks[i].restingFor == 0) {
                                this.tracks[i].execute();
                            }
                        } else {
                            this.tracks[i].restingFor--;
                        }
                    }
                }
            }

            startTrack(num, pc) {
                this.tracks[num].active = true;
                this.tracks[num].pc = pc;
                this.tracks[num].debugLog("Started! PC: " + hexN(pc, 6));
            }

            endTrack(num) {
                this.tracks[num].active = false;
                this.tracks[num].debugLog("Ended track.");
            }
        }

        class SseqTrack {
            constructor(controller, id) {
                /** @type {SseqController} */
                this.controller = controller;
                this.id = id;

                this.active = false;

                this.pc = 0;
                this.pan = 0;
                this.mono = false;
                this.volume = 0;
                this.priority = 0;
                this.program = 0;
                this.bank = 0;

                this.modulationDepth = 0;
                this.modulationSpeed = 0;
                this.modulationType = 0;
                this.modulationRange = 0;

                this.pitchBend = 0;
                this.pitchBendRange = 0;

                this.expression = 0;

                this.portamentoEnable = 0;
                this.portamentoTime = 0;

                this.restingFor = 0;

                this.stack = new Uint32Array(64);
                this.sp = 0;
            }

            debugLog(msg) {
                // console.log(`${this.id}: ${msg}`)
            }

            push(val) {
                this.stack[this.sp++] = val;
                if (this.sp >= this.stack.length) alert("SSEQ stack overflow");
            }

            pop() {
                if (this.sp == 0) alert("SSEQ stack underflow");
                return this.stack[--this.sp];
            }

            readPc() {
                return this.controller.sseqFile[this.pc + this.controller.dataOffset];
            }

            readPcInc(bytes = 1) {
                let val = 0;
                for (let i = 0; i < bytes; i++) {
                    val |= this.readPc() << (i * 8);
                    this.pc++;
                }

                return val;
            }

            readVariableLength(arr, offs) {
                let num = 0;
                for (let i = 0; i < 4; i++) {
                    let val = this.readPcInc();

                    num |= val & 0x7F;
                    num <<= 7;

                    if ((val & 0x80) == 0) {
                        break;
                    }
                }

                return num;
            }

            execute() {
                let opcodePc = this.pc;
                let opcode = this.readPcInc();

                if (opcode <= 0x7F) {
                    let velocity = this.readPcInc();
                    let duration = this.readVariableLength();

                    this.debugLog("Note: " + opcode);
                    this.debugLog("Velocity: " + velocity);
                    this.debugLog("Duration: " + duration);

                    this.controller.messageBuffer.insert(new Message(MessageType.PlayNote, opcode, velocity, duration));
                } else {
                    switch (opcode) {
                        case 0xFE: // Allocate track
                            {
                                // This probably isn't important for emulation
                                let alloced = this.readPcInc(2);

                                for (let i = 0; i < 16; i++) {
                                    if (bitTest(alloced, i)) {
                                        this.debugLog("Allocated track " + i);
                                    }
                                }
                                break;
                            }
                        case 0x93: // Start new track thread 
                            {
                                let trackNum = this.readPcInc();
                                let trackOffs = this.readPcInc(3);

                                this.controller.startTrack(trackNum, trackOffs);

                                this.debugLog("Started track thread " + trackNum);
                                this.debugLog("Offset: " + hex(trackOffs, 6));

                                break;
                            }
                        case 0xC7: // Mono / Poly
                            {
                                let param = this.readPcInc();
                                this.mono = bitTest(param, 0);
                                break;
                            }
                        case 0xCE: // Portamento On / Off
                            {
                                this.portamentoEnable = this.readPcInc();
                                this.debugLog("Portamento On / Off: " + this.portamentoEnable);
                                break;
                            }
                        case 0xCF: // Portamento Time
                            {
                                this.portamentoTime = this.readPcInc();
                                this.debugLog("Portamento Time: " + this.portamentoTime);
                                break;
                            }
                        case 0xE1: // BPM
                            {
                                this.bpm = this.readPcInc(2);
                                this.debugLog("BPM: " + this.bpm);
                                break;
                            }
                        case 0xC1: // Volume
                            {
                                this.volume = this.readPcInc();
                                this.debugLog("Volume: " + this.volume);
                                break;
                            }
                        case 0x81: // Set bank and program
                            {
                                let bankAndProgram = this.readVariableLength();
                                this.program = bankAndProgram & 0xFF;
                                this.bank = (bankAndProgram >> 8) & 0x7F;

                                this.debugLog("Program: " + this.program);
                                this.debugLog("Bank: " + this.bank);
                                break;
                            }
                        case 0xC2: // Master Volume
                            {
                                this.masterVolume = this.readPcInc();
                                this.debugLog("Master Volume: " + this.masterVolume);
                                break;
                            }
                        case 0xC0: // Pan
                            {
                                this.pan = this.readPcInc();
                                this.debugLog("Pan: " + this.pan);
                                break;
                            }
                        case 0xC6: // Track Priority
                            {
                                this.priority = this.readPcInc();
                                this.debugLog("Track Priority: " + this.priority);
                                break;
                            }
                        case 0xC5: // Pitch Bend Range
                            {
                                this.pitchBendRange = this.readPcInc();
                                this.debugLog("Pitch Bend Range: " + this.pitchBendRange);
                                break;
                            }
                        case 0xCA: // Modulation Depth
                            {
                                this.modulationDepth = this.readPcInc();
                                this.debugLog("Modulation Depth: " + this.modulationDepth);
                                break;
                            }
                        case 0xCB: // Modulation Speed
                            {
                                this.modulationSpeed = this.readPcInc();
                                this.debugLog("Modulation Speed: " + this.modulationSpeed);
                                break;
                            }
                        case 0xCC: // Modulation Type
                            {
                                this.modulationType = this.readPcInc();
                                this.debugLog("Modulation Type: " + this.modulationType);
                                break;
                            }
                        case 0xCD: // Modulation Range
                            {
                                this.modulationRange = this.readPcInc();
                                this.debugLog("ModulationRange: " + this.modulationRange);
                                break;
                            }
                        case 0xC4: // Pitch Bend
                            {
                                this.pitchBend = this.readPcInc();
                                this.debugLog("Pitch Bend: " + this.pitchBend);
                                break;
                            }
                        case 0x80: // Rest
                            {
                                this.restingFor = this.readVariableLength();
                                this.debugLog("Resting For: " + this.restingFor);
                                break;
                            }
                        case 0x94: // Jump
                            {
                                let dest = this.readPcInc(3);
                                this.pc = dest;
                                this.debugLog("Jump to: " + hexN(dest, 6));
                                break;
                            }
                        case 0x95: // Call
                            {
                                let dest = this.readPcInc(3);

                                // Push the return address
                                this.push(this.pc);
                                this.pc = dest;
                                break;
                            }
                        case 0xFD: // Return
                            {
                                this.pc = this.pop();
                                break;
                            }
                        case 0xB0: // TODO: According to sseq2mid: arithmetic operations?
                            {
                                this.readPcInc(3);
                                break;
                            }
                        case 0xE0: // Modulation Delay
                            {
                                this.modulationDelay = this.readPcInc(2);
                                this.debugLog("Modulation Delay: " + this.modulationDelay);
                                break;
                            }
                        case 0xD5: // Expression
                            {
                                this.expression = this.readPcInc();
                                this.debugLog("Expression: " + this.expression);
                                break;
                            }
                        case 0xFF: // End of Track
                            {
                                this.controller.endTrack(this.id);
                                // Set restingFor to non-zero since the controller checks it to stop executing
                                this.restingFor = 1;
                                break;
                            }
                        default:
                            alert(`${this.id}: Unknown opcode: ` + hex(opcode, 2) + " PC: " + hex(opcodePc, 6));
                    }
                }
            }
        }

        class Synthesizer {
            constructor(sampleRate, sample) {
                this.instrsAvailable = 16;

                this.instrs = new Array(this.instrsAvailable);
                this.instrsStartSample = new Float64Array(this.instrsAvailable);
                this.sampleNum = 0;
                this.sampleRate = sampleRate;

                this.valL = 0;
                this.valR = 0;

                this.playingIndex = 0;

                for (let i = 0; i < this.instrs.length; i++) {
                    if (sample != null) {
                        this.instrs[i] = new SampleInstrument(sampleRate, sample);
                    } else {
                        this.instrs[i] = new PsgSquareInstrument(sampleRate);
                    }
                }
            }

            play(frequency, volume) {
                this.instrs[this.playingIndex].playing = true;
                this.instrs[this.playingIndex].frequency = frequency;
                this.instrs[this.playingIndex].volume = volume;
                this.instrsStartSample[this.playingIndex] = this.sampleNum;

                this.playingIndex++;
                this.playingIndex %= this.instrsAvailable;
            }

            nextSample() {
                this.valL = 0;
                this.valR = 0;

                for (let i = 0; i < this.instrsAvailable; i++) {
                    if (this.instrs[i].playing)
                        this.instrs[i].sampleAt(this.sampleNum - this.instrsStartSample[i]);
                    this.valL += this.instrs[i].valL;
                    this.valR += this.instrs[i].valR;
                }

                this.sampleNum++;
            }

            getTime() {
                return this.sampleNum / this.sampleRate;
            }
        }

        function bitTest(i, bit) {
            return (i & (1 << bit)) !== 0;
        }

        /** @type {SseqController} */
        let currentlyPlaying = null;

        async function playSeq(sdat, name) {
            if (currentlyPlaying) {
                currentlyPlaying.destroy();
            }

            const BUFFER_SIZE = 16384;
            const SAMPLE_RATE = 131072;

            let sampleFrequency = 440 * 2 ** ((9 - 12) / 12);
            let synthtestSample = decodeWavToSample(await downloadFileFromUrl("synthtest.wav"), sampleFrequency);
            let synthesizer = new Synthesizer(SAMPLE_RATE, synthtestSample);

            let id = sdat.sseqNameIdDict[name];
            let info = sdat.sseqInfos[id];
            console.log("Playing SSEQ Id:" + id);
            console.log("FAT ID:" + info.fileId);

            let file = sdat.fat[info.fileId];
            let bufferL = new Float32Array(BUFFER_SIZE);
            let bufferR = new Float32Array(BUFFER_SIZE);

            let inBufferPos = 0;

            // // debugging hexdump
            // let offs = 0;
            // for (let i = 0; i < 16; i++) {
            //     let str = "";
            //     for (let j = 0; j < 16; j++) {
            //         str += hexN(file[offs], 2) + " ";
            //         offs++;
            //     }
            //     console.log(str);
            // }
            // console.log(String.fromCharCode(file[0], file[1], file[2], file[3]))

            let dataOffset = read32LE(file, 0x18);
            if (dataOffset != 0x1C) alert("SSEQ offset is not 0x1C? it is: " + hex(dataOffset, 8));

            let messageBuffer = new CircularBuffer(1024);
            let controller = new SseqController(file, dataOffset, messageBuffer);
            currentlyPlaying = controller;

            let timer = 0;
            controller.tick();
            function synthesizeMore() {
                for (let i = 0; i < BUFFER_SIZE; i++) {
                    timer += controller.tracks[0].bpm * 100;
                    while (timer >= SAMPLE_RATE) {
                        timer -= SAMPLE_RATE;

                        // 48 ticks per beat
                        controller.tick();

                        while (messageBuffer.entries > 0) {
                            /** @type {Message} */
                            let msg = messageBuffer.pop();

                            switch (msg.type) {
                                case MessageType.PlayNote:
                                    let midiNote = msg.param0;
                                    let hz = 440 * 2 ** ((midiNote - 69) / 12);
                                    synthesizer.play(hz, msg.param1 / 127 * 0.25);
                                    break;
                            }
                        }

                    }

                    // synthesizer.play(440);

                    synthesizer.nextSample();
                    bufferL[i] = synthesizer.valL;
                    bufferR[i] = synthesizer.valR;

                    if (controller.destroyed) {
                        return;
                    }
                }

                // synthesizer.play(Math.random() * 880);
                // synthesizer.play(Math.random() * 880);


                // console.log(inBufferPos);

                player.queueAudio(bufferL, bufferR);

                console.log("Syntheszing more audio");
            }

            let player = new AudioPlayer(BUFFER_SIZE, SAMPLE_RATE, synthesizeMore);
            synthesizeMore();
        }

        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        let indexTable = [-1, -1, -1, -1, 2, 4, 6, 8];
        let adpcmTable = [
            0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x0010, 0x0011, 0x0013, 0x0015,
            0x0017, 0x0019, 0x001C, 0x001F, 0x0022, 0x0025, 0x0029, 0x002D, 0x0032, 0x0037, 0x003C, 0x0042,
            0x0049, 0x0050, 0x0058, 0x0061, 0x006B, 0x0076, 0x0082, 0x008F, 0x009D, 0x00AD, 0x00BE, 0x00D1,
            0x00E6, 0x00FD, 0x0117, 0x0133, 0x0151, 0x0173, 0x0198, 0x01C1, 0x01EE, 0x0220, 0x0256, 0x0292,
            0x02D4, 0x031C, 0x036C, 0x03C3, 0x0424, 0x048E, 0x0502, 0x0583, 0x0610, 0x06AB, 0x0756, 0x0812,
            0x08E0, 0x09C3, 0x0ABD, 0x0BD0, 0x0CFF, 0x0E4C, 0x0FBA, 0x114C, 0x1307, 0x14EE, 0x1706, 0x1954,
            0x1BDC, 0x1EA5, 0x21B6, 0x2515, 0x28CA, 0x2CDF, 0x315B, 0x364B, 0x3BB9, 0x41B2, 0x4844, 0x4F7E,
            0x5771, 0x602F, 0x69CE, 0x7462, 0x7FFF
        ];

        // Decodes IMA-ADPCM to PCM16
        function decodeAdpcm(adpcmData) {
            let out = new Float64Array((adpcmData.length - 4) * 2);
            let outOffs = 0;

            let adpcmIndex = 0;

            let header = read32LE(adpcmData, 0);
            // ADPCM header
            let currentValue = header & 0xFFFF;
            adpcmIndex = clamp(header >> 16, 0, 88);

            for (let i = 4; i < adpcmData.length; i++) {
                for (let j = 0; j < 2; j++) {
                    let data = (adpcmData[i] >> (j * 4)) & 0xF;

                    let tableVal = adpcmTable[adpcmIndex];
                    let diff = tableVal >> 3;
                    if ((data & 1) != 0) diff += tableVal >> 2;
                    if ((data & 2) != 0) diff += tableVal >> 1;
                    if ((data & 4) != 0) diff += tableVal >> 0;

                    if ((data & 8) == 8) {
                        currentValue = Math.max(currentValue - diff, -0x7FFF);
                    }
                    else {
                        currentValue = Math.min(currentValue + diff, 0x7FFF);
                    }
                    adpcmIndex = clamp(adpcmIndex + indexTable[data & 7], 0, 88);

                    out[outOffs++] = currentValue;
                }
            }

            return out;
        }

        // Decode PCM16
        function decodePcm16(pcm16Data) {
            let out = new Float32Array(pcm16Data.length >> 1);

            for (let i = 0; i < out.length; i++) {
                out[i] = ((read16LE(pcm16Data, i * 2) << 16) >> 16) / 32767;
            }

            return out;
        }

        /** @param {Uint8Array} wavData */
        function decodeWavToSample(wavData, sampleFrequency) {
            /** @type {number[]} */
            let sampleData = [];

            let numChannels = read16LE(wavData, 22);
            let sampleRate = read32LE(wavData, 24);
            let bitsPerSample = read16LE(wavData, 34);

            console.log("decodeWav: sample rate: " + sampleRate);

            switch (bitsPerSample) {
                case 8:
                case 16:
                    break;
                default:
                    console.error("decodeWav: unsupported bits per sample: " + bitsPerSample);
                    return;
            }

            // Number of bytes in the wav data
            let subchunk2Size = read32LE(wavData, 40);


            for (let i = 44; i < 44 + subchunk2Size; i += bitsPerSample / 8 * numChannels) {
                switch (bitsPerSample) {
                    case 8:
                        sampleData.push(wavData[i] / 255);
                        break;
                    case 16:
                        sampleData.push(((read16LE(wavData, i) << 16) >> 16) / 32767);
                        break;
                }
            }

            return new Sample(Float64Array.from(sampleData), sampleFrequency, sampleRate);
        }

        function playStrm(strmData) {
            const BUFFER_SIZE = 2048;
            const SAMPLE_RATE = 131072;

            let bufferL = new Float32Array(BUFFER_SIZE);
            let bufferR = new Float32Array(BUFFER_SIZE);

            console.log("Number of Samples: " + read32LE(strmData, 0x24));

            let channels = strmData[0x1A];
            let numberOfBlocks = read32LE(strmData, 0x2C);
            let blockLength = read32LE(strmData, 0x30);
            let samplesPerBlock = read32LE(strmData, 0x34);
            let lastBlockLength = read32LE(strmData, 0x38);
            let lastBlockSamples = read32LE(strmData, 0x3C);

            console.log("Channels: " + channels)
            console.log("Number of blocks per channel: " + numberOfBlocks);
            console.log("Block length: " + blockLength)
            console.log("Samples per block: " + samplesPerBlock)
            console.log("Last block length: " + lastBlockLength)
            console.log("Last block samples: " + lastBlockSamples)

            if (numberOfBlocks > 2) alert("TODO: Support for block counts other than 2");
            if (channels < 2) alert("TODO: Support for mono audio");

            let sampleRate = read16LE(strmData, 0x1C);
            console.log("Sample Rate: " + sampleRate);
            console.log("Time: " + read16LE(strmData, 0x1E));

            let waveDataSize = blockLength;

            console.log("Wave data size: " + waveDataSize)

            let waveDataL = new Uint8Array(waveDataSize);
            let waveDataR = new Uint8Array(waveDataSize);

            for (let i = 0; i < waveDataSize; i++) {
                waveDataL[i] = strmData[0x68 + i];
                waveDataR[i] = strmData[0x68 + blockLength + i];
            }

            let decodedL;
            let decodedR;
            let format;
            switch (strmData[0x18]) {
                case 0: format = "PCM8"; break;
                case 1:
                    format = "PCM16";
                    decodedL = decodePcm16(waveDataL);
                    decodedR = decodePcm16(waveDataR);
                    break;
                case 2:
                    format = "IMA-ADPCM";
                    break;
            }

            console.log("Format: " + format);

            let inBufferPos = 0;
            let timer = 0;

            function synthesizeMore() {
                for (let i = 0; i < BUFFER_SIZE; i++) {
                    bufferL[i] = decodedL[inBufferPos];
                    bufferR[i] = decodedR[inBufferPos];

                    timer += sampleRate;
                    if (timer >= SAMPLE_RATE) {
                        timer -= SAMPLE_RATE;
                        if (++inBufferPos >= decodedL.length) {
                            inBufferPos = 0;
                        }
                    }
                }

                // console.log(inBufferPos);

                player.queueAudio(bufferL, bufferR);

                // console.log("Syntheszing more audio");
            }

            let player = new AudioPlayer(BUFFER_SIZE, SAMPLE_RATE, synthesizeMore);
            synthesizeMore();
        }

        function loadSdatFromRom(data, offset) {
            let sdat = new Sdat();

            let sdatSize = read32LE(data, offset + 0x8);
            console.log("SDAT file size: " + sdatSize);

            let sdatData = new Uint8Array(sdatSize);

            for (let i = 0; i < sdatSize; i++) {
                sdatData[i] = data[offset + i];
            }

            let numOfBlocks = read16LE(sdatData, 0xE);
            let headerSize = read16LE(sdatData, 0xC);

            console.log("Number of Blocks: " + numOfBlocks);
            console.log("Header Size: " + headerSize);

            if (headerSize > 256) {
                console.log("Header size too big (> 256), rejecting.");
                return;
            }

            let symbOffs = read32LE(sdatData, 0x10);
            let symbSize = read32LE(sdatData, 0x14);
            let infoOffs = read32LE(sdatData, 0x18);
            let infoSize = read32LE(sdatData, 0x1C);
            let fatOffs = read32LE(sdatData, 0x20);
            let fatSize = read32LE(sdatData, 0x24);
            let fileOffs = read32LE(sdatData, 0x28);
            let fileSize = read32LE(sdatData, 0x2C);

            console.log("SYMB Block Offset: " + hexN(symbOffs, 8));
            console.log("SYMB Block Size: " + hexN(symbSize, 8));
            console.log("INFO Block Offset: " + hexN(infoOffs, 8));
            console.log("INFO Block Size: " + hexN(infoSize, 8));
            console.log("FAT  Block Offset: " + hexN(fatOffs, 8));
            console.log("FAT  Block Size: " + hexN(fatSize, 8));
            console.log("FILE Block Offset: " + hexN(fileOffs, 8));
            console.log("FILE Block Size: " + hexN(fileSize, 8));

            // SYMB processing
            let symbSseqListOffs = read32LE(sdatData, symbOffs + 0x8);
            let symbSseqListNumEntries = read32LE(sdatData, symbOffs + symbSseqListOffs);

            console.log(hexN(offset + symbOffs + symbSseqListOffs, 8));
            console.log("SYMB Number of SSEQ entries: " + symbSseqListNumEntries);

            for (let i = 0; i < symbSseqListNumEntries; i++) {
                let sseqNameOffs = read32LE(sdatData, symbOffs + symbSseqListOffs + 4 + i * 4);

                let sseqNameArr = [];
                let sseqNameCharOffs = 0;
                while (true) {
                    let char = sdatData[symbOffs + sseqNameOffs + sseqNameCharOffs];
                    if (char == 0) break; // check for null terminator
                    sseqNameCharOffs++;
                    sseqNameArr.push(char);
                }

                // for some reason Pokemon Platinum has a ton of null pointers 
                if (sseqNameOffs != 0) {
                    let seqName = String.fromCharCode(...sseqNameArr);

                    sdat.sseqNameIdDict[seqName] = i;
                    sdat.sseqIdNameDict[i] = seqName;
                }
            }

            // INFO processing
            let infoSseqListOffs = read32LE(sdatData, infoOffs + 0x8);
            let infoSseqListNumEntries = read32LE(sdatData, infoOffs + infoSseqListOffs);
            console.log("INFO Number of SSEQ entries: " + infoSseqListNumEntries);

            for (let i = 0; i < infoSseqListNumEntries; i++) {
                let infoSseqNameOffs = read32LE(sdatData, infoOffs + infoSseqListOffs + 4 + i * 4);

                let info = new SseqInfo();
                info.fileId = read16LE(sdatData, infoOffs + infoSseqNameOffs + 0);
                info.bank = read16LE(sdatData, infoOffs + infoSseqNameOffs + 4);
                info.volume = sdatData[infoOffs + infoSseqNameOffs + 6];
                info.cpr = sdatData[infoOffs + infoSseqNameOffs + 7];
                info.ppr = sdatData[infoOffs + infoSseqNameOffs + 8];
                info.ply = sdatData[infoOffs + infoSseqNameOffs + 9];

                sdat.sseqInfos[i] = info;
            }

            // FAT / FILE processing
            let fatNumFiles = read32LE(sdatData, fatOffs + 8);
            console.log("FAT Number of files: " + fatNumFiles);

            for (let i = 0; i < fatNumFiles; i++) {
                let fileEntryOffs = fatOffs + 0xC + i * 0x10;

                let fileDataOffs = read32LE(sdatData, fileEntryOffs);
                let fileSize = read32LE(sdatData, fileEntryOffs + 4);

                let fileData = new Uint8Array(fileSize);

                for (let j = 0; j < fileSize; j++) {
                    fileData[j] = sdatData[fileDataOffs + j];
                }

                sdat.fat[i] = fileData;

                // console.log(`Loaded FAT file id:${i} size:${fileSize}`);
            }

            return sdat;
        }

        function searchForSequences(data, sequence) {
            let seqs = [];

            for (let i = 0; i < data.length; i++) {
                if (data[i] == sequence[0]) {
                    for (let j = 1; j < sequence.length; j++) {
                        if (data[i + j] != sequence[j]) {
                            break;
                        }

                        if (j == sequence.length - 1) seqs.push(i);
                    }
                }
            }

            return seqs;
        }

        function downloadFileFromUrl(url) {
            return new Promise((resolve, reject) => {
                let client = new XMLHttpRequest();
                client.responseType = "arraybuffer";
                client.open("GET", url);
                client.onreadystatechange = () => {
                    if (client.status != 404) {
                        if (client.response instanceof ArrayBuffer) {
                            resolve(new Uint8Array(client.response));
                            return;
                        }
                    } else {
                        reject();
                        return;
                    }
                };
                client.send();
            });
        }

        function loadFile(data) {
            console.log(`ROM size: ${data.length} bytes`);

            let sequence = [0x53, 0x44, 0x41, 0x54, 0xFF, 0xFE, 0x00, 0x01]; // "SDAT", then byte order 0xFEFF, then version 0x0100
            let res = searchForSequences(data, sequence);
            if (res.length > 0) {
                console.log(`Found SDATs at:`);
                for (let i = 0; i < res.length; i++) {
                    console.log(hex(res[i], 8));
                }
            } else {
                console.log(`Couldn't find SDAT (maybe not an NDS ROM?)`);
            }

            for (let i = 0; i < res.length; i++) {
                let sdat = loadSdatFromRom(data, res[i]);

                if (sdat != null) {
                    for (let i = 0; i < sdat.sseqIdNameDict.length; i++) {
                        let seqName = sdat.sseqIdNameDict[i];
                        if (seqName != undefined) {
                            let button = document.createElement('button');
                            button.innerText = seqName;
                            document.querySelector(".song-picker").appendChild(button);
                            button.onclick = () => {
                                console.log(seqName);
                                playSeq(sdat, seqName);
                            }
                        }
                    }

                    for (let i = 0; i < sdat.fat.length; i++) {
                        if (read32LE(sdat.fat[i], 0) == 0x4D525453) {
                            // alert(`file id:${i} is STRM`);

                            playStrm(sdat.fat[i]);
                        }
                    }
                }
            }

            /** @type {HTMLElement} */
            let filePickerContainer = document.querySelector("#file-picker-container")
            filePickerContainer.style.display = 'none';
        }

        window.onload = async () => {
            console.log("Optime Player");

            /** @type {HTMLElement} */
            let dropZone = document.querySelector('#drop-zone');
            /** @type {HTMLInputElement} */
            let filePicker = document.querySelector('#file-picker');

            dropZone.style.visibility = 'hidden';
            window.addEventListener('dragover', e => {
                e.preventDefault();
                // console.log("File dragged over");
                dropZone.style.visibility = 'visible';
            });
            dropZone.addEventListener('dragleave', e => {
                e.preventDefault();
                // console.log("File drag leave");
                dropZone.style.visibility = 'hidden';
            });
            window.addEventListener('drop', e => {
                e.preventDefault();
                if (e.dataTransfer.files[0] instanceof Blob) {
                    console.log("File dropped");

                    dropZone.style.visibility = 'hidden';

                    let reader = new FileReader();
                    reader.onload = function () {
                        if (this.result instanceof ArrayBuffer) {
                            loadFile(new Uint8Array(this.result));
                        }
                    }
                    reader.readAsArrayBuffer(e.dataTransfer.files[0]);
                }
            });

            filePicker.addEventListener("input", () => {
                if (filePicker.files && filePicker.files.length > 0) {
                    let file = filePicker.files[0];
                    let reader = new FileReader();
                    reader.readAsArrayBuffer(file);
                    reader.onload = function () {
                        let result = reader.result;
                        if (result instanceof ArrayBuffer) {
                            loadFile(new Uint8Array(result));
                        } else {
                            alert("Failed to read file! Probably a result of a lack of API support.");
                        }
                    };
                }
            });
        }
    </script>
</head>

<body>
    <div id='drop-zone'>
        <h1>Drop file!</h1>
    </div>
    <h1>Optime Player</h1>

    <div id="file-picker-container">
        <h3>Drag and drop a Nintendo DS ROM</h3>
        <p>or</p>
        <input type="file" id="file-picker" accept=".nds">
    </div>

    <div class="container">
        <div class="song-picker"></div>
        <div class="channels"></div>
    </div>
</body>

</html>